# MalwareDetection

**Feature Engineering and Dimensionality Reduction**

1. By doing basic analysis of features, we can observe that many features are unrelated to malware detection/prediction and can be dropped

-MachineIdentifier <br/>
-LocaleEnglishNameIdentifier <br/>
-Census_InternalBatteryType <br/>
-Census_InternalBatteryNumberOfCharges <br/>
-Census_OSInstallLanguageIdentifier <br/>
-Census_InternalPrimaryDiagonalDisplaySizeInInches <br/>
-Census_InternalPrimaryDisplayResolutionHorizontal <br/>
-Census_InternalPrimaryDisplayResolutionVertical <br/>
-Census_OSUILocaleIdentifier <br/>
-Census_IsTouchEnabled <br/>
-Census_IsPenCapable <br/>
-Census_IsAlwaysOnAlwaysConnectedCapable <br/>
-Wdft_RegionIdentifier <br/>

2. By looking at the % of null/empty values of columns, we can observe some features can be dropped

column                                                % empty<br/>

-PuaMode                                              99.9741 <br/>
-Census_ProcessorClass                                99.5894 <br/>
-DefaultBrowsersIdentifier                            95.1416 <br/>
-Census_IsFlightingInternal                           83.0440 <br/>
<br/>
80.0000 was taken as threshold
<br/>
<br/>
3. By looking at the unbalancedness of the feature values (i.e most of the values belonging to a single class), we can see that some features can be dropped

 column                             % unbalancedness     unique_vals

-Census_IsWIMBootEnabled             99.999969           2<br/>
-IsBeta                              99.999249           2<br/>
-Census_IsFlightsDisabled            99.998996           2<br/>
-AutoSampleOptIn                     99.997108           2<br/>
-Census_ThresholdOptIn               99.974924           2<br/>
-SMode                               99.953708           2<br/>
-Census_IsPortableOperatingSystem    99.945480           2<br/> 
-Census_DeviceFamily                 99.838256           3<br/>
-UacLuaenable                        99.392547           11<br/>
-Census_IsVirtualDevice              99.296055           2<br/>

99.0000 was taken as threshold<br/>

4. By looking at the correlation plot, we can drop some features <br/>

 Feature 1 vs Feature 2   =  corr<br/>

-AvSigVersion vs EngineVersion = 0.97<br/>
-IsSxsPassiveMode vs RtpStateBitfield = -0.90<br/>
-IeVerIdentifier vs OsBuildLab = 0.91<br/>
-OsVer vs Platform = 0.99<br/>
-SkuEdition vs OsSuite = -0.90<br/>
-Census_OSEdition vs Census_OSSkuName = 1.00 <br/>
-Census_OSVersion vs Census_OSBuildNumber = 0.97<br/>
-Census_OSArchitecture vs Processor = 1.0<br/>

The following features were removed in the above case<br/>

-EngineVersion (AvSigVersion conveys more info than EngineVersion )<br/>
-RtpStateBitfield (IsSxsPassiveMode conveys more info than RtpStateBitfield )<br/>
-IeVerIdentifier (OsBuildLab conveys more info than IeVerIdentifier )<br/>
-Platform (OsVer has more unique values than Platform)<br/>
-SkuEdition (OsSuite is numerical though it may be categorical and SkuEdition is a nominal variable)<br/>
-Census_OSSkuName (Census_OSEdition has more unique values than Census_OSSkuName)<br/>
-Census_OSBuildNumber (Census_OSVersion conveys more info than Census_OSBuildNumber)<br/>
-Processor (Census_OSArchitecture conveys more info than Processor)<br/>
<br/>
After removing all the features, there are 2 features which have a significant % of missing values<br/>
<br/>
column                                                % empty<br/>

-SmartScreen                                          35.6108<br/>
-OrganizationIdentifier                               30.8415<br/>

The missing values in SmartScreen can be replaced by it's default value which is RequireAdmin. Source : https://en.wikipedia.org/wiki/Microsoft_SmartScreen<br/>

The missing values in OrganizationIdentifier can be replaced by 0.<br/>

All this is done by feature.py<br/>

Additonally, notebook called "Malware Detection by Exploratory Territory.ipynb" provides data visualization along with contents of feature.py to back the feature choice and dropping.<br/>

To view the notebook on github use nbviewer as it gives proper rendering of plotly plots.<br/>

Alternatively, it is also hosted as private kernel at https://www.kaggle.com/mehulthakral/malware-detection-by-exploratory-territory <br/>

Steps to run :<br/>

1) Install all requirements numpy,matplotlib,pandas and seaborn (all are there in kaggle)
2) Additionally install chart_studio (from kaggle console in case of kaggle) for ploting plots using plotly.  
3) Change the path of the train.csv in "Loading the data" part use /kaggle/input/microsoft-malware-prediction/train.csv as path if using it in kaggle
4) Change path of the destination where the new_train.csv must be stored
<br/>
The new csv will have all the unwanted features removed.


Models Tried

1. LSTM : LSTM was tried. It is available in LSTM.py. The AUC was 0.50 approx
2. LSTM-CNN : Available in LSTM_CNN.py. results similar to LSTM were obtained
3. LightGBM : Testing

Observation : 

NeuralNets are not appropriate

<hr>

<h5> Time Series </h5>
This kind of malware risk detection is in essence a time series problem, with the sampling date of each data point greatly influencing the some of the system’s properties. The given dataset is also split into test and train in such a way that a majority of entries in the train data are from August and September 2018 while the training data is mostly
from October and November 2018.(As seen in LGBM_EDA.ipynb)
<br>
But the problems posed to the traditional time series approach by this dataset are the following:
<br>
• New systems are added to the dataset with time.
<br>
• There are systems that occasionally go offline for variable durations of time. No data from these systems are recorded in this period.
<br>
• Systems receive OS patches, bug fixes and OS upgrades over time thereby changing their properties. 
<br>
This analysis is intuitive as newer versions of operating systems and antivirus software to combat ever-improving malware.

<hr>

<h5> Light Gradient Boosting Machine </h5>
The proposed solution, that best suits the given dataset, is to build a Gradient Boosting Machine using the LGBM framework to predict the probability of a machine being hit by a malware soon. The model is further enhanced to better represent the underlying time series aspect of the problem by handcrafting new features, as a part of feature engineering.(WeekNo as seen in LGBM_EDA.ipynb amd LGBM_model1.py)

